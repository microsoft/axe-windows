<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BoundingRectangleNotValidButOffScreen" xml:space="preserve">
    <value>The BoundingRectangle property is not valid, but the element is off-screen.</value>
  </data>
  <data name="BoundingRectangleOnUWPMenuBar" xml:space="preserve">
    <value>The BoundingRectangle property of a menubar in UWP may have a null or empty value.</value>
  </data>
  <data name="BoundingRectangleOnUWPMenuItem" xml:space="preserve">
    <value>The BoundingRectangle property of a menu item in UWP may have a null or empty value.</value>
  </data>
  <data name="BoundingRectangleOnWPFTextParent" xml:space="preserve">
    <value>The BoundingRectangle property of a given element in the WPF framework whose parent is of type text may have a null or empty value.</value>
  </data>
  <data name="ButtonWithSplitButtonParentPattern" xml:space="preserve">
    <value>A button element should only support the one of Invoke, Toggle, or ExpandCollapse patterns when a splitbutton is the parent. </value>
  </data>
  <data name="SiblingUniqueAndNotFocusable" xml:space="preserve">
    <value>The given element has siblings with the same Name and LocalizedControlType.</value>
  </data>
  <data name="ComboBoxShouldNotSupportScrollPattern" xml:space="preserve">
    <value>A combo box should not support the Scroll pattern. This rule may be reported as a warning because some platforms have combo boxes support the scroll pattern by default, which app developers can't easily fix.</value>
  </data>
  <data name="ControlShouldNotSupportValuePattern" xml:space="preserve">
    <value>An element of the given type should not support the Value pattern.</value>
  </data>
  <data name="ControlShouldNotSupportWindowPattern" xml:space="preserve">
    <value>An element of the given type should not support the Window pattern.</value>
  </data>
  <data name="EditSupportsOnlyValuePattern" xml:space="preserve">
    <value>It is best when Edit controls support the Text pattern. The Value pattern is acceptable, but much less accessible.</value>
  </data>
  <data name="HelpTextNotEqualToName" xml:space="preserve">
    <value>The HelpText property of an element must not be the same as the element's Name property.</value>
  </data>
  <data name="IsContentElementFalseOptional" xml:space="preserve">
    <value>The recommended value of the IsContentElement property for the given control type is false. Please consider if this is an element that should be reported to an assistive technology user as content.</value>
  </data>
  <data name="IsContentElementTrueOptional" xml:space="preserve">
    <value>The recommended value of the IsContentElement property for the given control type is true. Please consider if this is an element that should be reported to an assistive technology user as content.</value>
  </data>
  <data name="IsControlElementTrueOptional" xml:space="preserve">
    <value>The recommended value of the IsControlElement property for the given control type is true. Please consider if this is an element that should be reported to an assistive technology user as a control. Note that almost all controls are required to have the IsControl Property set to true.</value>
  </data>
  <data name="IsKeyboardFocusableShouldBeTrue" xml:space="preserve">
    <value>The IsKeyboardFocusable property for the given element should be true based on its control type.</value>
  </data>
  <data name="IsKeyboardFocusableFalseButDisabled" xml:space="preserve">
    <value>The IsKeyboardFocusable property is false for an element where it would normally be true. However, the IsEnabled property on the element is also false, so the value of IsKeyboardFocusable may be acceptable.</value>
  </data>
  <data name="IsKeyboardFocusableForListItemShouldBeTrue" xml:space="preserve">
    <value>The IsKeyboardFocusable property for the given list item is false, but the element has children that are focusable. The element should probably be focusable instead of its children.</value>
  </data>
  <data name="IsKeyboardFocusableFalseButOffscreen" xml:space="preserve">
    <value>The IsKeyboardFocusable property for the given element is false for an element where it would normally be true. However, the IsOffscreen property on the element is true, so the value of IsKeyboardFocusable may be acceptable.</value>
  </data>
  <data name="IsKeyboardFocusableForCustomShouldBeTrue" xml:space="preserve">
    <value>The IsKeyboardFocusable property for a custome element should be true when the element supports actionable patterns.</value>
  </data>
  <data name="IsKeyboardFocusableDescendantTextPattern" xml:space="preserve">
    <value>The IsKeyboardFocusable property may be false when the given element supports the text pattern and is the descendant of an element that also supports the text pattern. Please consider if the given element should or should not be focusable.</value>
  </data>
  <data name="IsKeyboardFocusableOnEmptyContainer" xml:space="preserve">
    <value>The IsKeyboardFocusable property should be true when you want an empty container to be discoverable by assistive technology users. IsKeyboardFocusable may be false when you want an empty container not to be discoverable by AT users.</value>
  </data>
  <data name="IsKeyboardFocusableShouldBeFalse" xml:space="preserve">
    <value>The IsKeyboardFocusable property for the given element is expected to be false because of the element's control type.</value>
  </data>
  <data name="IsKeyboardFocusableTopLevelTextPattern" xml:space="preserve">
    <value>The IsKeyboardFocusable property should be true for an element that supports the text pattern, is not a descendant of an element that supports the text pattern, and which supports text selection.</value>
  </data>
  <data name="ItemStatusExists" xml:space="preserve">
    <value>The ItemStatus property for the given element should exist.</value>
  </data>
  <data name="LocalizedControlTypeReasonable" xml:space="preserve">
    <value>The localized control type should be reasonable based on ControlTypeId.</value>
  </data>
  <data name="ItemTypeRecommended" xml:space="preserve">
    <value>The ItemType property for the given element has no content, and the element has a child image. Please consider including an item type so that assistive technology users can obtain the information provided by the image. If this information is already provided in another way, the item type may not be necessary.</value>
  </data>
  <data name="NameEmptyButElementNotKeyboardFocusable" xml:space="preserve">
    <value>The UIAutomation Name property for the given element is empty, but the element isn't focusable. Please consider whether or not the element should have a name.</value>
  </data>
  <data name="NameNoSiblingsOfSameType" xml:space="preserve">
    <value>The UI Automation Name property of the given element may be null or empty if the element has no siblings of the same type.</value>
  </data>
  <data name="NameNullButElementNotKeyboardFocusable" xml:space="preserve">
    <value>The UI Automation Name property for the given element is null, but the element isn't focusable. Please consider whether or not the element should have a name.</value>
  </data>
  <data name="NameOnCustomWithParentWPFDataItem" xml:space="preserve">
    <value>The UI Automation Name property of a custom control may be empty if the parent is a wpf dataitem.</value>
  </data>
  <data name="NameOnOptionalType" xml:space="preserve">
    <value>The UI Automation Name property for the given element type is optional.</value>
  </data>
  <data name="NameWithValidBoundingRectangle" xml:space="preserve">
    <value>An interactive element with a valid UI Automation Name property is usually expected to have a valid bounding rectangle that is not null and has area.</value>
  </data>
  <data name="Structure" xml:space="preserve">
    <value>The given element is expected to have the following structure: {0}.</value>
  </data>
  <data name="SelectionPatternSelectionRequired" xml:space="preserve">
    <value>Set the element's IsSelectionRequired property of the SelectionPattern to TRUE.</value>
  </data>
  <data name="ButtonInvokeAndExpandCollapsePatterns" xml:space="preserve">
    <value>A button may have invoke and expandcollapse patterns together. but it is not recommended. if possible, please have only one of them. </value>
  </data>
  <data name="ButtonShouldHavePatterns" xml:space="preserve">
    <value>Modify the button to support exactly one of the following patterns:
 · Support the Invoke pattern if the button performs a command at the request of the user.
 · Support the Toggle pattern if the button can cycle through a series of up to three states.
 · Support the ExpandCollapse pattern if the button shows or hides additional content.</value>
  </data>
  <data name="ButtonInvokeAndTogglePatterns" xml:space="preserve">
    <value>Modify the button to support exactly one of the following patterns:
 · Support the Invoke pattern if the button performs a command at the request of the user.
 · Support the Toggle pattern if the button can cycle through a series of up to three states.
 · Support the ExpandCollapse pattern if the button shows or hides additional content.</value>
  </data>
  <data name="ButtonToggleAndExpandCollapsePatterns" xml:space="preserve">
    <value>Modify the button to support exactly one of the following patterns:
 · Support the Invoke pattern if the button performs a command at the request of the user.
 · Support the Toggle pattern if the button can cycle through a series of up to three states.
 · Support the ExpandCollapse pattern if the button shows or hides additional content.</value>
  </data>
  <data name="ProgressBarRangeValue" xml:space="preserve">
    <value>Implement the progress bar's RangeValue pattern using the following properties and values:
 · Minimum: 0.0
 · Maximum: 100.0
 · IsReadOnly: TRUE</value>
  </data>
  <data name="EditSupportsIncorrectRangeValuePattern" xml:space="preserve">
    <value>Implement the edit control's RangeValue pattern with a null LargeChange property.</value>
  </data>
  <data name="SplitButtonInvokeAndTogglePatterns" xml:space="preserve">
    <value>Modify the split button to support exactly one of the following patterns:
 · Support the Invoke pattern if the button performs a command at the request of the user.
 · Support the Toggle pattern if the button can cycle through a series of up to three states.</value>
  </data>
  <data name="ControlShouldNotSupportInvokePattern" xml:space="preserve">
    <value>1. Make sure the element has the appropriate ControlType property for its function.
2. Modify the element to support only its allowed patterns.</value>
  </data>
  <data name="ControlShouldNotSupportScrollPattern" xml:space="preserve">
    <value>1. Make sure the element has the appropriate ControlType property for its function.
2. Modify the element to support only its allowed patterns.</value>
  </data>
  <data name="ControlShouldNotSupportTablePattern" xml:space="preserve">
    <value>1. Make sure the element has the appropriate ControlType property for its function.
2. Modify the element to support only its allowed patterns.</value>
  </data>
  <data name="ControlShouldNotSupportTogglePattern" xml:space="preserve">
    <value>1. Make sure the element has the appropriate ControlType property for its function.
2. Modify the element to support only its allowed patterns.</value>
  </data>
  <data name="ControlShouldSupportExpandCollapsePattern" xml:space="preserve">
    <value>1. Make sure the element has the appropriate ControlType property for its function.
2. If the current ControlType is correct, modify the element to support the ExpandCollapse pattern.</value>
  </data>
  <data name="ControlShouldSupportGridItemPattern" xml:space="preserve">
    <value>Modify the element (or one of its children) to support the GridItem pattern.</value>
  </data>
  <data name="ControlShouldSupportGridPattern" xml:space="preserve">
    <value>1. Make sure the element has the appropriate ControlType property for its function.
2. If the current ControlType is correct, modify the element to support the Grid pattern.</value>
  </data>
  <data name="ControlShouldSupportInvokePattern" xml:space="preserve">
    <value>1. Make sure the element has the appropriate ControlType property for its function.
2. If the current ControlType is correct, modify the element to support the Invoke pattern.</value>
  </data>
  <data name="ControlShouldSupportScrollItemPattern" xml:space="preserve">
    <value>Modify the element (or one of its children) to support the ScrollItem pattern.</value>
  </data>
  <data name="ControlShouldSupportSelectionItemPattern" xml:space="preserve">
    <value>1. Make sure the element has the appropriate ControlType property for its function.
2. If the current ControlType is correct, modify the element to support the SelectionItem pattern.</value>
  </data>
  <data name="ControlShouldSupportSelectionPattern" xml:space="preserve">
    <value>1. Make sure the element has the appropriate ControlType property for its function.
2. If the current ControlType is correct, modify the element to support the Selection pattern.</value>
  </data>
  <data name="ControlShouldSupportSpreadsheetItemPattern" xml:space="preserve">
    <value>Modify the element (or one of its children) to support the SpreadsheetItem pattern.</value>
  </data>
  <data name="ControlShouldSupportTableItemPattern" xml:space="preserve">
    <value>Modify the element (or one of its children) to support the TableItem pattern.</value>
  </data>
  <data name="ControlShouldSupportTablePattern" xml:space="preserve">
    <value>1. Make sure the element has the appropriate ControlType property for its function.
2. If the current ControlType is correct, modify the element to support the Table pattern.</value>
  </data>
  <data name="ControlShouldSupportTextPattern" xml:space="preserve">
    <value>1. Make sure the element has the appropriate ControlType property for its function.
2. If the current ControlType is correct, modify the element to support the Text pattern.</value>
  </data>
  <data name="ControlShouldSupportTogglePattern" xml:space="preserve">
    <value>1. Make sure the element has the appropriate ControlType property for its function.
2. If the current ControlType is correct, modify the element to support the Toggle pattern.</value>
  </data>
  <data name="ControlShouldSupportTransformPattern" xml:space="preserve">
    <value>If the element can be resized, implement the Transform pattern.
If the element can't be resized, ensure the TransformPattern_CanResize property is FALSE.</value>
  </data>
  <data name="ChildrenNotAllowedInContentView" xml:space="preserve">
    <value>Make sure all of the element's children have the IsContentElement property set to FALSE.</value>
  </data>
  <data name="SelectionPatternSingleSelection" xml:space="preserve">
    <value>1. Make sure the element has the appropriate ControlType property for its function.
2. Make sure Selection is the correct pattern.
3. Set the element's CanSelectMultiple property to FALSE.</value>
  </data>
  <data name="SelectionItemPatternSingleSelection" xml:space="preserve">
    <value>Do one of the following:
 1. Modify the element and/or its siblings so that only one of them is selected at any given time, OR
 2. Modify the parent element so its CanSelectMultiple property is TRUE.</value>
  </data>
  <data name="ParentChildShouldNotHaveSameNameAndLocalizedControlType" xml:space="preserve">
    <value>Provide unique names for controls that have a parent/child relationship and the same ControlType property.</value>
  </data>
  <data name="SiblingUniqueAndFocusable" xml:space="preserve">
    <value>Provide unique names for sibling controls that have the same ControlType property.</value>
  </data>
  <data name="ControlShouldSupportSetInfo" xml:space="preserve">
    <value>Provide valid values for the SizeOfSet and PositionInSet properties.</value>
  </data>
  <data name="BoundingRectangleCompletelyObscuresContainer" xml:space="preserve">
    <value>Modify one or both bounding rectangles to ensure that the bounding rectangle of the container element is not completely obscured.</value>
  </data>
  <data name="BoundingRectangleContainedInParent" xml:space="preserve">
    <value>Modify one or both bounding rectangles to ensure that the element's bounding rectangle is contained within the bounding rectangle of its parent.</value>
  </data>
  <data name="BoundingRectangleDataFormatCorrect" xml:space="preserve">
    <value>Make sure the BoundingRectangle property returns data in the expected format:
 1. Specify the rectangle as an array with a type of double and a size of 4.
 2. Specify the rectangle's position and size (in pixels) by providing array values in the following order:
    a. Top edge
    b. Left edge
    c. Width
    d. Height</value>
  </data>
  <data name="BoundingRectangleNotAllZeros" xml:space="preserve">
    <value>Specify the rectangle's position and size (in pixels) by providing array values in the following order:
 1. Top edge
 2. Left edge
 3. Width
 4. Height</value>
  </data>
  <data name="BoundingRectangleNotNull" xml:space="preserve">
    <value>If the element is offscreen, set its IsOffscreen property to TRUE.
If the element is onscreen, provide a BoundingRectangle property.</value>
  </data>
  <data name="BoundingRectangleSizeReasonable" xml:space="preserve">
    <value>Modify the BoundingRectangle property so that its width and height define an area of at least 25 pixels.</value>
  </data>
  <data name="HeadingLevelDescendsWhenNested" xml:space="preserve">
    <value>Modify the heading levels and/or nesting structure of the element and/or its ancestors.
For example, if an element has a level-5 heading, its descendants can have only level-5 or level-6 headings.</value>
  </data>
  <data name="IsContentElementPropertyExists" xml:space="preserve">
    <value>Provide a value for the element's IsContentElement property:
 · If the element should be included in the content view, set the property to TRUE.
 · If the element should not be included in the content view, set the property to FALSE.</value>
  </data>
  <data name="IsControlElementPropertyExists" xml:space="preserve">
    <value>Provide a value for the element's IsControlElement property:
 · If the element should be included in the control view, set the property to TRUE.
 · If the element should not be included in the control view, set the property to FALSE.</value>
  </data>
  <data name="IsControlElementTrueRequired" xml:space="preserve">
    <value>Set the element's IsControlElement property to TRUE.</value>
  </data>
  <data name="LandmarkBannerIsTopLevel" xml:space="preserve">
    <value>Modify the banner element so it does not descend from any other landmark.
      Exception: If a page has nested document or application roles, each nested document or application may have one banner landmark.</value>
  </data>
  <data name="LandmarkComplementaryIsTopLevel" xml:space="preserve">
    <value>Modify the complementary landmark so it does not descend from any other landmark.
      Exception: If a page has nested document or application roles, each nested document or application may have one complementary landmark.</value>
  </data>
  <data name="LandmarkContentInfoIsTopLevel" xml:space="preserve">
    <value>Modify the contentinfo landmark so it does not descend from any other landmark.
      Exception: If a page has nested document or application roles, each nested document or application may have one contentinfo landmark.</value>
  </data>
  <data name="LandmarkMainIsTopLevel" xml:space="preserve">
    <value>Modify the main landmark so it does not descend from any other landmark.
      Exception: If a page has nested document or application roles, each nested document or application may have one main landmark.</value>
  </data>
  <data name="LandmarkNoDuplicateBanner" xml:space="preserve">
    <value>Use the banner landmark only once per page.
      Exception: If a page has nested document or application roles, each nested document or application may have a banner landmark.</value>
  </data>
  <data name="LandmarkNoDuplicateContentInfo" xml:space="preserve">
    <value>Use the contentinfo landmark only once per page.</value>
  </data>
  <data name="LandmarkOneMain" xml:space="preserve">
    <value>Provide exactly one main landmark per page.</value>
  </data>
  <data name="LocalizedLandmarkTypeExcludesSpecialCharacters" xml:space="preserve">
    <value>Provide a string for the LocalizedLandmarkType property that does not include any special characters.
Where appropriate, use a standard localized landmark type:
 · Use "banner" for an area at the beginning of the page with site-oriented content.
 · Use "complementary" for an area with supporting content that remains meaningful when separated from the primary content.
 · Use "contentinfo" for an area at the end of the page containing information about the site or the primary content.
 · Use "form" for an area containing a set of form-related elements.
 · Use "main" for the area with the page's primary content.
 · Use "navigation" for an area containing links for page or site navigation.
 · Use "search" for an area of the page containing search functionality.
If none of the standard landmark types is applicable, provide a string that concisely describes its content.</value>
  </data>
  <data name="LocalizedLandmarkTypeIsReasonableLength" xml:space="preserve">
    <value>Provide a string for the LocalizedLandmarkType property that contains at most 64 characters.
Where appropriate, use a standard localized landmark type:
 · Use "banner" for an area at the beginning of the page with site-oriented content.
 · Use "complementary" for an area with supporting content that remains meaningful when separated from the primary content.
 · Use "contentinfo" for an area at the end of the page containing information about the site or the primary content.
 · Use "form" for an area containing a set of form-related elements.
 · Use "main" for the area with the page's primary content.
 · Use "navigation" for an area containing links for page or site navigation.
 · Use "search" for an area of the page containing search functionality.
If none of the standard landmark types is applicable, provide a string that concisely describes its content.</value>
  </data>
  <data name="LocalizedLandmarkTypeNotCustom" xml:space="preserve">
    <value>Provide string for the LocalizedLandmarkType property that does not include "custom."
Where appropriate, use a standard localized landmark type:
 · Use "banner" for an area at the beginning of the page with site-oriented content.
 · Use "complementary" for an area with supporting content that remains meaningful when separated from the primary content.
 · Use "contentinfo" for an area at the end of the page containing information about the site or the primary content.
 · Use "form" for an area containing a set of form-related elements.
    ·         Use "main" for the area with the page's primary content.
    ·         Use "navigation" for an area containing links for page or site navigation.
    ·         Use "search" for an area of the page containing search functionality.
If none of the standard landmark types is applicable, provide a string that concisely describes its content.</value>
  </data>
  <data name="LocalizedLandmarkTypeNotEmpty" xml:space="preserve">
    <value>Provide a string for the LocalizedLandmarkType property.
Where appropriate, use a standard localized landmark type:
 · Use "banner" for an area at the beginning of the page with site-oriented content.
 · Use "complementary" for an area with supporting content that remains meaningful when separated from the primary content.
 · Use "contentinfo" for an area at the end of the page containing information about the site or the primary content.
 · Use "form" for an area containing a set of form-related elements.
 · Use "main" for the area with the page's primary content.
    ·         Use "navigation" for an area containing links for page or site navigation.
    ·         Use "search" for an area of the page containing search functionality.
If none of the standard landmark types is applicable, provide a string that concisely describes its content.</value>
  </data>
  <data name="LocalizedLandmarkTypeNotNull" xml:space="preserve">
    <value>Provide a LocalizedLandmarkType property for the element.
Where appropriate, use a standard localized landmark type:
 · Use "banner" for an area at the beginning of the page with site-oriented content.
 · Use "complementary" for an area with supporting content that remains meaningful when separated from the primary content.
 · Use "contentinfo" for an area at the end of the page containing information about the site or the primary content.
 · Use "form" for an area containing a set of form-related elements.
 · Use "main" for the area with the page's primary content.
 · Use "navigation" for an area containing links for page or site navigation.
 · Use "search" for an area of the page containing search functionality.
If none of the standard landmark types is applicable, provide a string that concisely describes its content.</value>
  </data>
  <data name="LocalizedLandmarkTypeNotWhiteSpace" xml:space="preserve">
    <value>Provide a string for the LocalizedLandmarkType property.
Where appropriate, use a standard localized landmark type:
 · Use "banner" for an area at the beginning of the page with site-oriented content.
 · Use "complementary" for an area with supporting content that remains meaningful when separated from the primary content.
 · Use "contentinfo" for an area at the end of the page containing information about the site or the primary content.
 · Use "form" for an area containing a set of form-related elements.
 · Use "main" for the area with the page's primary content.
 · Use "navigation" for an area containing links for page or site navigation.
 · Use "search" for an area of the page containing search functionality.
If none of the standard landmark types is applicable, provide a string that concisely describes its content.</value>
  </data>
  <data name="LocalizedControlTypeNotCustom" xml:space="preserve">
    <value>Sufficient:
Provide a string for the LocalizedControlType property that concisely describes the control's function or purpose.

Better:
If possible, use a predefined (non-custom) control type and the default localized control type. The UIA framework will provide the correct localized control type automatically.</value>
  </data>
  <data name="LocalizedControlTypeNotEmpty" xml:space="preserve">
    <value>Provide a string for the LocalizedControlType property that concisely describes the control's type.</value>
  </data>
  <data name="LocalizedControlTypeNotNull" xml:space="preserve">
    <value>Provide a string for the LocalizedControlType property that concisely describes the control's type.</value>
  </data>
  <data name="LocalizedControlTypeNotWhiteSpace" xml:space="preserve">
    <value>Provide a string for the LocalizedControlType property that concisely describes the control's type.</value>
  </data>
  <data name="OrientationPropertyExists" xml:space="preserve">
    <value>Provide an Orientation property for the element.</value>
  </data>
  <data name="NameExcludesControlType" xml:space="preserve">
    <value>Provide a UI Automation Name property for the element that:
 · Concisely identifies the element, AND
 · Does not include the control type.</value>
  </data>
  <data name="NameExcludesLocalizedControlType" xml:space="preserve">
    <value>Provide a UI Automation Name property for the element that:
 · Concisely identifies the element, AND
 · Does not include the same text as the element's LocalizedControlType property.</value>
  </data>
  <data name="NameExcludesSpecialCharacters" xml:space="preserve">
    <value>Provide a UI Automation Name property for the element that:
 · Concisely identifies the element, AND
 · Does not include any special characters.</value>
  </data>
  <data name="NameIsInformative" xml:space="preserve">
    <value>Provide a UI Automation Name property for the element that:
 · Concisely identifies the element, AND
 · Does not include the element's class name (such as Microsoft.*.* or Windows.*.*).</value>
  </data>
  <data name="NameNotEmpty" xml:space="preserve">
    <value>Provide a UI Automation Name property that concisely identifies the element.</value>
  </data>
  <data name="NameNotNull" xml:space="preserve">
    <value>Provide a UI Automation Name property that concisely identifies the element.</value>
  </data>
  <data name="NameNotWhiteSpace" xml:space="preserve">
    <value>Provide a UI Automation Name property that concisely identifies the element.</value>
  </data>
  <data name="NameReasonableLength" xml:space="preserve">
    <value>Provide a UI Automation Name property for the element that:
 · Concisely identifies the element, AND
 · Contains at most 512 characters.</value>
  </data>
  <data name="ListItemSiblingsUnique" xml:space="preserve">
    <value>Provide unique names for sibling list items.</value>
  </data>
</root>